import { ShaderMaterial, Vector2, Uniform, NoBlending, WebGLRenderTarget, LinearFilter, Scene, Camera, BufferGeometry, BufferAttribute, Mesh, MeshStandardMaterial } from 'three';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';

class ConvolutionMaterial extends ShaderMaterial {
  constructor(texelSize = new Vector2()) {
    super({
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        halfTexelSize: new Uniform(new Vector2()),
        kernel: new Uniform(0.0),
        scale: new Uniform(1.0),
        cameraNear: new Uniform(0.0),
        cameraFar: new Uniform(1.0),
        minDepthThreshold: new Uniform(0.0),
        maxDepthThreshold: new Uniform(1.0),
        depthScale: new Uniform(0.0),
        depthToBlurRatioBias: new Uniform(0.25)
      },
      fragmentShader: "#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\n          #endif\n          \n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\n          gl_FragColor = sum * 0.25 ;\n\n          #include <dithering_fragment>\n        }",
      vertexShader: "uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",
      blending: NoBlending,
      depthWrite: false,
      depthTest: false
    });

    _defineProperty(this, "kernel", void 0);

    this.toneMapped = false;
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernel = new Float32Array([0.0, 1.0, 2.0, 2.0, 3.0]);
  }

  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
    this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
  }

  setResolution(resolution) {
    this.uniforms.resolution.value.copy(resolution);
  }

}

class BlurPass {
  constructor({
    gl,
    resolution,
    width = 500,
    height = 500,
    minDepthThreshold = 0,
    maxDepthThreshold = 1,
    depthScale = 0,
    depthToBlurRatioBias = 0.25
  }) {
    _defineProperty(this, "renderTargetA", void 0);

    _defineProperty(this, "renderTargetB", void 0);

    _defineProperty(this, "convolutionMaterial", void 0);

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "camera", void 0);

    _defineProperty(this, "screen", void 0);

    _defineProperty(this, "renderToScreen", false);

    this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer: false,
      depthBuffer: false,
      encoding: gl.outputEncoding
    });
    this.renderTargetB = this.renderTargetA.clone();
    this.convolutionMaterial = new ConvolutionMaterial();
    this.convolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);
    this.convolutionMaterial.setResolution(new Vector2(width, height));
    this.scene = new Scene();
    this.camera = new Camera();
    this.convolutionMaterial.uniforms.minDepthThreshold.value = minDepthThreshold;
    this.convolutionMaterial.uniforms.maxDepthThreshold.value = maxDepthThreshold;
    this.convolutionMaterial.uniforms.depthScale.value = depthScale;
    this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = depthToBlurRatioBias;
    this.convolutionMaterial.defines.USE_DEPTH = depthScale > 0;
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new BufferAttribute(vertices, 3));
    geometry.setAttribute('uv', new BufferAttribute(uvs, 2));
    this.screen = new Mesh(geometry, this.convolutionMaterial);
    this.screen.frustumCulled = false;
    this.scene.add(this.screen);
  }

  render(renderer, inputBuffer, outputBuffer) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    let material = this.convolutionMaterial;
    let uniforms = material.uniforms;
    uniforms.depthBuffer.value = inputBuffer.depthTexture;
    const kernel = material.kernel;
    let lastRT = inputBuffer;
    let destRT;
    let i, l; // Apply the multi-pass blur.

    for (i = 0, l = kernel.length - 1; i < l; ++i) {
      // Alternate between targets.
      destRT = (i & 1) === 0 ? renderTargetA : renderTargetB;
      uniforms.kernel.value = kernel[i];
      uniforms.inputBuffer.value = lastRT.texture;
      renderer.setRenderTarget(destRT);
      renderer.render(scene, camera);
      lastRT = destRT;
    }

    uniforms.kernel.value = kernel[i];
    uniforms.inputBuffer.value = lastRT.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }

}

class MeshReflectorMaterial extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);

    _defineProperty(this, "_debug", {
      value: 0
    });

    _defineProperty(this, "_tDepth", {
      value: null
    });

    _defineProperty(this, "_distortionMap", {
      value: null
    });

    _defineProperty(this, "_tDiffuse", {
      value: null
    });

    _defineProperty(this, "_tDiffuseBlur", {
      value: null
    });

    _defineProperty(this, "_textureMatrix", {
      value: null
    });

    _defineProperty(this, "_hasBlur", {
      value: false
    });

    _defineProperty(this, "_mirror", {
      value: 0.0
    });

    _defineProperty(this, "_mixBlur", {
      value: 0.0
    });

    _defineProperty(this, "_blurStrength", {
      value: 0.5
    });

    _defineProperty(this, "_minDepthThreshold", {
      value: 0.9
    });

    _defineProperty(this, "_maxDepthThreshold", {
      value: 1
    });

    _defineProperty(this, "_depthScale", {
      value: 0
    });

    _defineProperty(this, "_depthToBlurRatioBias", {
      value: 0.25
    });

    _defineProperty(this, "_distortion", {
      value: 1
    });

    this.setValues(parameters);
  }

  onBeforeCompile(shader) {
    var _shader$defines;

    if (!((_shader$defines = shader.defines) == null ? void 0 : _shader$defines.USE_UV)) {
      shader.defines.USE_UV = '';
    }

    shader.uniforms.debug = this._debug;
    shader.uniforms.hasBlur = this._hasBlur;
    shader.uniforms.tDiffuse = this._tDiffuse;
    shader.uniforms.tDepth = this._tDepth;
    shader.uniforms.distortionMap = this._distortionMap;
    shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;
    shader.uniforms.textureMatrix = this._textureMatrix;
    shader.uniforms.mirror = this._mirror;
    shader.uniforms.mixBlur = this._mixBlur;
    shader.uniforms.mixStrength = this._blurStrength;
    shader.uniforms.minDepthThreshold = this._minDepthThreshold;
    shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;
    shader.uniforms.depthScale = this._depthScale;
    shader.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias;
    shader.uniforms.distortion = this._distortion;
    shader.vertexShader = "\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;     \n      " + shader.vertexShader;
    shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', "#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );");
    shader.fragmentShader = "\n        uniform int debug;\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;        \n        " + shader.fragmentShader;
    shader.fragmentShader = shader.fragmentShader.replace('#include <emissivemap_fragment>', "#include <emissivemap_fragment>\n    \n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n      \n      vec4 merge = base;\n      \n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);;\n        #else\n          merge = merge * depthFactor;\n        #endif\n  \n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n      \n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + merge.rgb * mixStrength);           \n      diffuseColor = sRGBToLinear(diffuseColor);\n      \n      if (debug == 1) {\n        diffuseColor = sRGBToLinear(vec4(vec3(depthFactor), 1.0));\n      }\n      if (debug == 2) {\n        diffuseColor = sRGBToLinear(vec4(vec3(blurFactor), 1.0));\n      }\n      if (debug == 3) {\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuse, new_vUv));\n      }\n      if (debug == 4) {\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuseBlur, new_vUv));\n      }\n      ");
  }

  get tDiffuse() {
    return this._tDiffuse.value;
  }

  set tDiffuse(v) {
    this._tDiffuse.value = v;
  }

  get tDepth() {
    return this._tDepth.value;
  }

  set tDepth(v) {
    this._tDepth.value = v;
  }

  get distortionMap() {
    return this._distortionMap.value;
  }

  set distortionMap(v) {
    this._distortionMap.value = v;
  }

  get tDiffuseBlur() {
    return this._tDiffuseBlur.value;
  }

  set tDiffuseBlur(v) {
    this._tDiffuseBlur.value = v;
  }

  get textureMatrix() {
    return this._textureMatrix.value;
  }

  set textureMatrix(v) {
    this._textureMatrix.value = v;
  }

  get hasBlur() {
    return this._hasBlur.value;
  }

  set hasBlur(v) {
    this._hasBlur.value = v;
  }

  get mirror() {
    return this._mirror.value;
  }

  set mirror(v) {
    this._mirror.value = v;
  }

  get mixBlur() {
    return this._mixBlur.value;
  }

  set mixBlur(v) {
    this._mixBlur.value = v;
  }

  get mixStrength() {
    return this._blurStrength.value;
  }

  set mixStrength(v) {
    this._blurStrength.value = v;
  }

  get minDepthThreshold() {
    return this._minDepthThreshold.value;
  }

  set minDepthThreshold(v) {
    this._minDepthThreshold.value = v;
  }

  get maxDepthThreshold() {
    return this._maxDepthThreshold.value;
  }

  set maxDepthThreshold(v) {
    this._maxDepthThreshold.value = v;
  }

  get depthScale() {
    return this._depthScale.value;
  }

  set depthScale(v) {
    this._depthScale.value = v;
  }

  get debug() {
    return this._debug.value;
  }

  set debug(v) {
    this._debug.value = v;
  }

  get depthToBlurRatioBias() {
    return this._depthToBlurRatioBias.value;
  }

  set depthToBlurRatioBias(v) {
    this._depthToBlurRatioBias.value = v;
  }

  get distortion() {
    return this._distortion.value;
  }

  set distortion(v) {
    this._distortion.value = v;
  }

}

export { BlurPass as B, MeshReflectorMaterial as M };
