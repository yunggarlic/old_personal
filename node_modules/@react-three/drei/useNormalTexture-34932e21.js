import CloudImage from './assets/cloud.base64.js';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { forwardRef, createElement, useRef, useMemo, useState, useLayoutEffect, useEffect, Children, useImperativeHandle, Fragment, useContext, createContext, useCallback, cloneElement } from 'react';
import { useFrame, useLoader, useUpdate, useThree, extend, applyProps, createPortal, addEffect, addAfterEffect } from 'react-three-fiber';
import mergeRefs from 'react-merge-refs';
import { TextureLoader, Vector2, Vector3, Color, QuadraticBezierCurve3, CubicBezierCurve3, AudioListener, AudioLoader, PMREMGenerator, CubeTextureLoader, WebGLMultisampleRenderTarget, RGBAFormat, sRGBEncoding, WebGLCubeRenderTarget, LinearFilter, RGBFormat, Raycaster, Camera, Object3D, Matrix4, Quaternion, Scene, CanvasTexture, DefaultLoadingManager, Ray, Sphere as Sphere$1, Plane as Plane$1, Vector4, PerspectiveCamera as PerspectiveCamera$1, WebGLRenderTarget, DepthTexture, DepthFormat, UnsignedShortType, Box3, AnimationMixer, BufferGeometry, MeshPhysicalMaterial, MeshStandardMaterial, ShaderMaterial, UniformsUtils, ShaderChunk, Spherical, AdditiveBlending, PlaneBufferGeometry, Mesh, MeshDepthMaterial, Shape, BufferAttribute, RepeatWrapping } from 'three';
import { LineGeometry } from 'three/examples/jsm/lines/LineGeometry';
import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial';
import { Line2 } from 'three/examples/jsm/lines/Line2';
import { Text as Text$1 } from 'troika-three-text';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader';
import { useAsset } from 'use-asset';
import { presetsObj } from './helpers/environment-assets.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
import { GammaCorrectionShader } from 'three/examples/jsm/shaders/GammaCorrectionShader';
import { SimplexNoise } from 'three/examples/jsm/math/SimplexNoise';
import { DeviceOrientationControls as DeviceOrientationControls$1 } from 'three/examples/jsm/controls/DeviceOrientationControls';
import { FlyControls as FlyControls$1 } from 'three/examples/jsm/controls/FlyControls';
import { MapControls as MapControls$1, OrbitControls as OrbitControls$1 } from 'three/examples/jsm/controls/OrbitControls';
import { TrackballControls as TrackballControls$1 } from 'three/examples/jsm/controls/TrackballControls';
import { TransformControls as TransformControls$1 } from 'three/examples/jsm/controls/TransformControls';
import pick from 'lodash.pick';
import omit from 'lodash.omit';
import { PointerLockControls as PointerLockControls$1 } from 'three/examples/jsm/controls/PointerLockControls';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';
import { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';
import create$1 from 'zustand';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { M as MeshReflectorMaterial, B as BlurPass } from './MeshReflectorMaterial-fdc52c9a.js';
import StatsImpl from 'three/examples/js/libs/stats.min';
import { getGPUTier } from 'detect-gpu';
import { SimplifyModifier } from 'three/examples/jsm/modifiers/SimplifyModifier';
import { TessellateModifier } from 'three/examples/jsm/modifiers/TessellateModifier';
import { EdgeSplitModifier } from 'three/examples/jsm/modifiers/EdgeSplitModifier';
import { Flow } from 'three/examples/jsm/modifiers/CurveModifier';
import { Sky as Sky$1 } from 'three/examples/jsm/objects/Sky';
import { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader';
import { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader';
import { matcapList } from './helpers/matcap-assets.js';
import { normalsList } from './helpers/normal-assets.js';

function create(type) {
  const El = type + 'BufferGeometry';
  return /*#__PURE__*/forwardRef((_ref, ref) => {
    let {
      args,
      children
    } = _ref,
        props = _objectWithoutPropertiesLoose(_ref, ["args", "children"]);

    return /*#__PURE__*/createElement("mesh", _extends({
      ref: ref
    }, props), /*#__PURE__*/createElement(El, {
      attach: "geometry",
      args: args
    }), children);
  });
}

const Box = create('box');
const Circle = create('circle');
const Cone = create('cone');
const Cylinder = create('cylinder');
const Sphere = create('sphere');
const Plane = create('plane');
const Tube = create('tube');
const Torus = create('torus');
const TorusKnot = create('torusKnot');
const Tetrahedron = create('tetrahedron');
const Ring = create('ring');
const Polyhedron = create('polyhedron');
const Icosahedron = create('icosahedron');
const Octahedron = create('octahedron');
const Dodecahedron = create('dodecahedron');
const Extrude = create('extrude');
const Lathe = create('lathe');
const Parametric = create('parametric');

const Billboard = /*#__PURE__*/forwardRef(function Billboard(_ref, ref) {
  let {
    follow = true,
    lockX = false,
    lockY = false,
    lockZ = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["follow", "lockX", "lockY", "lockZ"]);

  const localRef = useRef();
  useFrame(({
    camera
  }) => {
    if (!follow) return;

    if (localRef.current) {
      const prev = {
        x: localRef.current.rotation.x,
        y: localRef.current.rotation.y,
        z: localRef.current.rotation.z
      };
      localRef.current.lookAt(camera.position); // readjust any axis that is locked

      if (lockX) localRef.current.rotation.x = prev.x;
      if (lockY) localRef.current.rotation.y = prev.y;
      if (lockZ) localRef.current.rotation.z = prev.z;
    }
  });
  return /*#__PURE__*/createElement(Plane, _extends({
    ref: mergeRefs([localRef, ref])
  }, props));
});

function useTexture(url) {
  return useLoader(TextureLoader, url);
}

useTexture.preload = url => useLoader.preload(TextureLoader, url);

function Cloud(_ref) {
  let {
    opacity = 0.5,
    speed = 0.4,
    width = 10,
    length = 1.5,
    segments = 20,
    dir = 1
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["opacity", "speed", "width", "length", "segments", "dir"]);

  const group = useRef();
  const texture = useTexture(CloudImage);
  const clouds = useMemo(() => [...new Array(segments)].map((_, index) => ({
    x: width / 2 - Math.random() * width,
    y: width / 2 - Math.random() * width,
    scale: 0.4 + Math.sin((index + 1) / segments * Math.PI) * ((0.2 + Math.random()) * 10),
    density: Math.max(0.2, Math.random()),
    rotation: Math.max(0.002, 0.005 * Math.random()) * speed
  })), [width, segments, speed]);
  useFrame(state => {
    var _group$current;

    return (_group$current = group.current) == null ? void 0 : _group$current.children.forEach((cloud, index) => {
      cloud.rotation.z += clouds[index].rotation * dir;
      cloud.scale.setScalar(clouds[index].scale + (1 + Math.sin(state.clock.getElapsedTime() / 10)) / 2 * index / 10);
    });
  });
  return /*#__PURE__*/createElement("group", props, /*#__PURE__*/createElement("group", {
    position: [0, 0, segments / 2 * length],
    ref: group
  }, clouds.map(({
    x,
    y,
    scale,
    density
  }, index) => /*#__PURE__*/createElement(Billboard, {
    key: index,
    scale: [scale, scale, scale],
    position: [x, y, -index * length],
    lockZ: true
  }, /*#__PURE__*/createElement("meshStandardMaterial", {
    map: texture,
    transparent: true,
    opacity: scale / 6 * density * opacity,
    depthTest: false
  })))));
}

const Detailed = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    distances
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "distances"]);

  const lod = useUpdate(lod => {
    lod.levels.length = 0;
    lod.children.forEach((object, index) => lod.levels.push({
      object,
      distance: distances[index]
    }));
  }, []);
  useFrame(state => {
    var _lod$current;

    return (_lod$current = lod.current) == null ? void 0 : _lod$current.update(state.camera);
  });
  return /*#__PURE__*/createElement("lOD", _extends({
    ref: mergeRefs([lod, ref])
  }, props), children);
});

const Line = /*#__PURE__*/forwardRef(function Line(_ref, ref) {
  let {
    points,
    color = 'black',
    vertexColors,
    lineWidth,
    dashed
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["points", "color", "vertexColors", "lineWidth", "dashed"]);

  const [line2] = useState(() => new Line2());
  const [lineMaterial] = useState(() => new LineMaterial());
  const [resolution] = useState(() => new Vector2(512, 512));
  const lineGeom = useMemo(() => {
    const geom = new LineGeometry();
    const pValues = points.map(p => p instanceof Vector3 ? p.toArray() : p);
    geom.setPositions(pValues.flat());

    if (vertexColors) {
      const cValues = vertexColors.map(c => c instanceof Color ? c.toArray() : c);
      geom.setColors(cValues.flat());
    }

    return geom;
  }, [points, vertexColors]);
  useLayoutEffect(() => {
    line2.computeLineDistances();
  }, [points, line2]);
  useLayoutEffect(() => {
    if (dashed) {
      lineMaterial.defines.USE_DASH = '';
    } else {
      // Setting lineMaterial.defines.USE_DASH to undefined is apparently not sufficient.
      delete lineMaterial.defines.USE_DASH;
    }

    lineMaterial.needsUpdate = true;
  }, [dashed, lineMaterial]);
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: line2,
    ref: ref
  }, rest), /*#__PURE__*/createElement("primitive", {
    dispose: undefined,
    object: lineGeom,
    attach: "geometry"
  }), /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: lineMaterial,
    attach: "material",
    color: color,
    vertexColors: Boolean(vertexColors),
    resolution: resolution,
    linewidth: lineWidth,
    dashed: dashed
  }, rest)));
});

const QuadraticBezierLine = /*#__PURE__*/forwardRef(function QuadraticBezierLine(_ref, ref) {
  let {
    start,
    end,
    mid,
    segments = 20
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["start", "end", "mid", "segments"]);

  const points = useMemo(() => {
    const startV = start instanceof Vector3 ? start : new Vector3(...start);
    const endV = end instanceof Vector3 ? end : new Vector3(...end);
    const mid2 = mid || startV.clone().add(endV.clone().sub(startV)).add(new Vector3(0, startV.y - endV.y, 0));
    const midV = mid2 instanceof Vector3 ? mid2 : new Vector3(...mid2);
    const interpolatedV = new QuadraticBezierCurve3(startV, midV, endV).getPoints(segments);
    return interpolatedV;
  }, [start, end, mid, segments]);
  return /*#__PURE__*/createElement(Line, _extends({
    ref: ref,
    points: points
  }, rest));
});

const CubicBezierLine = /*#__PURE__*/forwardRef(function CubicBezierLine(_ref, ref) {
  let {
    start,
    end,
    midA,
    midB,
    segments = 20
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["start", "end", "midA", "midB", "segments"]);

  const points = useMemo(() => {
    const startV = start instanceof Vector3 ? start : new Vector3(...start);
    const endV = end instanceof Vector3 ? end : new Vector3(...end);
    const midAV = midA instanceof Vector3 ? midA : new Vector3(...midA);
    const midBV = midB instanceof Vector3 ? midB : new Vector3(...midB);
    const interpolatedV = new CubicBezierCurve3(startV, midAV, midBV, endV).getPoints(segments);
    return interpolatedV;
  }, [start, end, midA, midB, segments]);
  return /*#__PURE__*/createElement(Line, _extends({
    ref: ref,
    points: points
  }, rest));
});

const PositionalAudio = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    url,
    distance = 1,
    loop = true
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["url", "distance", "loop"]);

  const sound = useRef();
  const {
    camera
  } = useThree();
  const [listener] = useState(() => new AudioListener());
  const buffer = useLoader(AudioLoader, url);
  useEffect(() => {
    const _sound = sound.current;

    if (_sound) {
      _sound.setBuffer(buffer);

      _sound.setRefDistance(distance);

      _sound.setLoop(loop);

      _sound.play();
    }

    camera.add(listener);
    return () => {
      camera.remove(listener);

      if (_sound) {
        _sound.stop();

        _sound.disconnect();
      }
    };
  }, [buffer, camera, distance, listener, loop]);
  return /*#__PURE__*/createElement("positionalAudio", _extends({
    ref: mergeRefs([sound, ref]),
    args: [listener]
  }, props));
});

// eslint-disable-next-line prettier/prettier
const Text = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    anchorX = 'center',
    anchorY = 'middle',
    children,
    onSync
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["anchorX", "anchorY", "children", "onSync"]);

  const {
    invalidate
  } = useThree();
  const [troikaMesh] = useState(() => new Text$1());
  const [nodes, text] = useMemo(() => {
    let n = [];
    let t = '';
    Children.forEach(children, child => {
      if (typeof child === 'string' || typeof child === 'number') {
        t += child;
      } else {
        n.push(child);
      }
    });
    return [n, t];
  }, [children]);
  useLayoutEffect(() => void troikaMesh.sync(() => {
    invalidate();
    if (onSync) onSync(troikaMesh);
  }));
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: troikaMesh,
    ref: ref,
    text: text,
    anchorX: anchorX,
    anchorY: anchorY
  }, props), nodes);
});

function getTexture(texture, gen, isCubeMap) {
  if (isCubeMap) {
    gen.compileEquirectangularShader();
    return gen.fromCubemap(texture).texture;
  }

  return gen.fromEquirectangular(texture).texture;
}

const CUBEMAP_ROOT = 'https://rawcdn.githack.com/mattrossman/drei-assets/b597559ff62f85ec691df28cbea5ecb1263a2085';
function Environment({
  background = false,
  files = ['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'],
  path = '/',
  preset = undefined,
  scene
}) {
  if (preset) {
    if (!(preset in presetsObj)) {
      throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));
    }

    files = presetsObj[preset];
    path = CUBEMAP_ROOT + '/hdri/';
  }

  const {
    gl,
    scene: defaultScene
  } = useThree();
  const isCubeMap = Array.isArray(files);
  const loader = isCubeMap ? CubeTextureLoader : RGBELoader; // @ts-expect-error

  const loaderResult = useLoader(loader, isCubeMap ? [files] : files, loader => loader.setPath(path));
  const map = isCubeMap ? loaderResult[0] : loaderResult; // PMREMGenerator takes its sweet time to generate the env-map,
  // Let's make this part of suspense, or else it just yields a frame-skip

  const texture = useAsset(() => new Promise(res => {
    const gen = new PMREMGenerator(gl);
    const texture = getTexture(map, gen, isCubeMap);
    gen.dispose();
    map.dispose();
    res(texture);
  }), map);
  useLayoutEffect(() => {
    const oldbg = scene ? scene.background : defaultScene.background;
    const oldenv = scene ? scene.environment : defaultScene.environment;

    if (scene) {
      scene.environment = texture;

      if (background) {
        scene.background = texture;
      }
    } else {
      defaultScene.environment = texture;

      if (background) {
        defaultScene.background = texture;
      }
    }

    return () => {
      if (scene) {
        scene.environment = oldenv;
        scene.background = oldbg;
      } else {
        defaultScene.environment = oldenv;
        defaultScene.background = oldbg;
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [texture, background, scene]);
  return null;
}

extend({
  EffectComposer,
  RenderPass,
  ShaderPass
});
const isWebGL2Available = () => {
  try {
    var canvas = document.createElement('canvas');
    return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'));
  } catch (e) {
    return false;
  }
};
const Effects = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    multisamping = 8,
    renderIndex = 1,
    disableGamma = false,
    disableRenderPass = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "multisamping", "renderIndex", "disableGamma", "disableRenderPass"]);

  const composer = useRef();
  const {
    scene,
    camera,
    gl,
    size
  } = useThree();
  const [target] = useState(() => {
    if (isWebGL2Available() && multisamping > 0) {
      const t = new WebGLMultisampleRenderTarget(size.width, size.height, {
        format: RGBAFormat,
        encoding: sRGBEncoding
      });
      t.samples = 8;
      return t;
    }
  });
  useEffect(() => {
    var _composer$current, _composer$current2;

    (_composer$current = composer.current) == null ? void 0 : _composer$current.setSize(size.width, size.height);
    (_composer$current2 = composer.current) == null ? void 0 : _composer$current2.setPixelRatio(gl.getPixelRatio());
  }, [gl, size]);
  useFrame(() => {
    var _composer$current3;

    return (_composer$current3 = composer.current) == null ? void 0 : _composer$current3.render();
  }, renderIndex);
  return /*#__PURE__*/createElement("effectComposer", _extends({
    ref: mergeRefs([ref, composer]),
    args: [gl, target]
  }, props), !disableRenderPass && /*#__PURE__*/createElement("renderPass", {
    attachArray: "passes",
    args: [scene, camera]
  }), !disableGamma && /*#__PURE__*/createElement("shaderPass", {
    attachArray: "passes",
    args: [GammaCorrectionShader]
  }), children);
});

const OrthographicCamera = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    makeDefault = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["makeDefault"]);

  const {
    setDefaultCamera,
    camera,
    size
  } = useThree();
  const cameraRef = useUpdate(cam => cam.updateProjectionMatrix(), [size, props]);
  useLayoutEffect(() => {
    if (makeDefault && cameraRef.current) {
      const oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return () => setDefaultCamera(oldCam);
    }
  }, [camera, cameraRef, makeDefault, setDefaultCamera]);
  return /*#__PURE__*/createElement("orthographicCamera", _extends({
    left: size.width / -2,
    right: size.width / 2,
    top: size.height / 2,
    bottom: size.height / -2,
    ref: mergeRefs([cameraRef, ref])
  }, props));
});

const PerspectiveCamera = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    makeDefault = false
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["makeDefault"]);

  const {
    setDefaultCamera,
    camera,
    size
  } = useThree();
  const cameraRef = useUpdate(cam => {
    cam.aspect = size.width / size.height;
    cam.updateProjectionMatrix();
  }, [size, props]);
  useLayoutEffect(() => {
    if (makeDefault && cameraRef.current) {
      const oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return () => setDefaultCamera(oldCam);
    }
  }, [camera, cameraRef, makeDefault, setDefaultCamera]);
  return /*#__PURE__*/createElement("perspectiveCamera", _extends({
    ref: mergeRefs([cameraRef, ref])
  }, props));
});

const CameraShake = /*#__PURE__*/forwardRef(({
  intensity = 1,
  decay,
  decayRate = 0.65,
  maxYaw = 0.1,
  maxPitch = 0.1,
  maxRoll = 0.1,
  yawFrequency = 1,
  pitchFrequency = 1,
  rollFrequency = 1,
  additive
}, ref) => {
  const {
    camera
  } = useThree();
  const intensityRef = useRef(intensity);
  const [yawNoise] = useState(() => new SimplexNoise());
  const [pitchNoise] = useState(() => new SimplexNoise());
  const [rollNoise] = useState(() => new SimplexNoise());

  const constrainIntensity = () => {
    if (intensityRef.current < 0 || intensityRef.current > 1) {
      intensityRef.current = intensityRef.current < 0 ? 0 : 1;
    }
  };

  useImperativeHandle(ref, () => ({
    getIntensity: () => intensityRef.current,
    setIntensity: val => {
      intensityRef.current = val;
      constrainIntensity();
    }
  }), []);
  useFrame(({
    clock
  }, delta) => {
    const shake = Math.pow(intensityRef.current, 2);
    const yaw = maxYaw * shake * yawNoise.noise(clock.elapsedTime * yawFrequency, 1);
    const pitch = maxPitch * shake * pitchNoise.noise(clock.elapsedTime * pitchFrequency, 1);
    const roll = maxRoll * shake * rollNoise.noise(clock.elapsedTime * rollFrequency, 1);

    if (additive) {
      camera.rotation.x += pitch;
      camera.rotation.y += yaw;
      camera.rotation.z += roll;
    } else {
      camera.rotation.set(pitch, yaw, roll);
    }

    if (decay && intensityRef.current > 0) {
      intensityRef.current -= decayRate * delta;
      constrainIntensity();
    }
  });
  return null;
});

function CubeCamera(_ref) {
  let {
    children,
    fog,
    frames = Infinity,
    resolution = 256,
    near = 1,
    far = 1000
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "fog", "frames", "resolution", "near", "far"]);

  const ref = useRef();
  const [camera, setCamera] = useState();
  const {
    scene,
    gl
  } = useThree();
  const fbo = useMemo(() => new WebGLCubeRenderTarget(resolution, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBFormat,
    encoding: gl.outputEncoding
  }), [resolution]);
  let count = 0;
  useFrame(() => {
    if (camera && ref.current && (frames === Infinity || count < frames)) {
      ref.current.traverse(obj => obj.visible = false);
      const originalFog = scene.fog;
      scene.fog = fog != null ? fog : originalFog;
      camera.update(gl, scene);
      scene.fog = originalFog;
      ref.current.traverse(obj => obj.visible = true);
      count++;
    }
  });
  return /*#__PURE__*/createElement("group", props, /*#__PURE__*/createElement("cubeCamera", {
    ref: setCamera,
    args: [near, far, fbo]
  }), /*#__PURE__*/createElement("group", {
    ref: ref
  }, children(fbo.texture)));
}

function call(ref, value) {
  if (typeof ref === 'function') ref(value);else if (ref != null) ref.current = value;
}

function useEffectfulState(fn, deps = [], cb) {
  const [state, set] = useState();
  useLayoutEffect(() => {
    const value = fn();
    set(value);
    call(cb, value);
    return () => call(cb, null); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
  return state;
}

const DeviceOrientationControls = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    camera
  } = props,
        rest = _objectWithoutPropertiesLoose(props, ["camera"]);

  const {
    camera: defaultCamera,
    invalidate
  } = useThree();
  const explCamera = camera || defaultCamera;
  const controls = useEffectfulState(() => {
    if (explCamera) {
      return new DeviceOrientationControls$1(explCamera);
    }
  }, [explCamera], ref);
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  useFrame(() => controls == null ? void 0 : controls.update());
  useEffect(() => {
    const current = controls;
    current == null ? void 0 : current.connect();
    return () => current == null ? void 0 : current.dispose();
  }, [controls]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, rest)) : null;
});

const FlyControls = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    camera,
    gl,
    invalidate
  } = useThree();
  const controls = useEffectfulState(() => new FlyControls$1(camera, gl.domElement), [camera, gl.domElement], ref);
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  useFrame((_, delta) => controls == null ? void 0 : controls.update(delta));
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, props)) : null;
});

const MapControls = /*#__PURE__*/forwardRef((props = {
  enableDamping: true
}, ref) => {
  const {
    camera
  } = props,
        rest = _objectWithoutPropertiesLoose(props, ["camera"]);

  const {
    camera: defaultCamera,
    gl,
    invalidate
  } = useThree();
  const explCamera = camera || defaultCamera;
  const controls = useEffectfulState(() => {
    if (explCamera) {
      return new MapControls$1(explCamera, gl.domElement);
    }
  }, [explCamera, gl], ref);
  useFrame(() => controls == null ? void 0 : controls.update());
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls,
    enableDamping: true
  }, rest)) : null;
});

const OrbitControls = /*#__PURE__*/forwardRef((props = {
  enableDamping: true
}, ref) => {
  const {
    camera
  } = props,
        rest = _objectWithoutPropertiesLoose(props, ["camera"]);

  const {
    camera: defaultCamera,
    gl,
    invalidate
  } = useThree();
  const explCamera = camera || defaultCamera;
  const controls = useEffectfulState(() => {
    if (explCamera) {
      return new OrbitControls$1(explCamera, gl.domElement);
    }
  }, [explCamera, gl], ref);
  useFrame(() => controls == null ? void 0 : controls.update());
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls,
    enableDamping: true
  }, rest)) : null;
});

const TrackballControls = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    camera
  } = props,
        rest = _objectWithoutPropertiesLoose(props, ["camera"]);

  const {
    camera: defaultCamera,
    gl,
    invalidate
  } = useThree();
  const explCamera = camera || defaultCamera;
  const controls = useEffectfulState(() => {
    if (explCamera) {
      return new TrackballControls$1(explCamera, gl.domElement);
    }
  }, [explCamera, gl], ref);
  useFrame(() => controls == null ? void 0 : controls.update());
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, rest)) : null;
});

const TransformControls = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const transformOnlyPropNames = ['enabled', 'axis', 'mode', 'translationSnap', 'rotationSnap', 'scaleSnap', 'space', 'size', 'dragging', 'showX', 'showY', 'showZ'];

  const {
    camera
  } = props,
        rest = _objectWithoutPropertiesLoose(props, ["camera"]);

  const transformProps = pick(rest, transformOnlyPropNames);
  const objectProps = omit(rest, transformOnlyPropNames);
  const {
    camera: defaultCamera,
    gl,
    invalidate
  } = useThree();
  const explCamera = camera || defaultCamera;
  const controls = useEffectfulState(() => {
    if (explCamera) {
      return new TransformControls$1(explCamera, gl.domElement);
    }
  }, [explCamera, gl.domElement], ref);
  const group = useRef();
  useLayoutEffect(() => void (controls == null ? void 0 : controls.attach(group.current)), [children, controls]);
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  return controls ? /*#__PURE__*/createElement(Fragment, null, /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, transformProps)), /*#__PURE__*/createElement("group", _extends({
    ref: group
  }, objectProps), children)) : null;
});

const PointerLockControls = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    selector
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["selector"]);

  const {
    camera
  } = props,
        rest = _objectWithoutPropertiesLoose(props, ["camera"]);

  const {
    camera: defaultCamera,
    gl,
    invalidate
  } = useThree();
  const explCamera = camera || defaultCamera;
  const controls = useEffectfulState(() => {
    if (explCamera) {
      return new PointerLockControls$1(explCamera, gl.domElement);
    }
  }, [explCamera, gl.domElement], ref);
  useEffect(() => {
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener('change', invalidate);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener('change', invalidate);
  }, [controls, invalidate]);
  useEffect(() => {
    const handler = () => controls == null ? void 0 : controls.lock();

    const element = selector ? document.querySelector(selector) : document;
    element && element.addEventListener('click', handler);
    return () => element ? element.removeEventListener('click', handler) : undefined;
  }, [controls, selector]);
  return controls ? /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: controls
  }, rest)) : null;
});

function useCamera(camera, props) {
  const {
    mouse
  } = useThree();
  const [raycast] = useState(() => {
    let raycaster = new Raycaster();
    if (props) applyProps(raycaster, props, {});
    return function (_, intersects) {
      raycaster.setFromCamera(mouse, camera instanceof Camera ? camera : camera.current);
      const rc = this.constructor.prototype.raycast.bind(this);
      if (rc) rc(raycaster, intersects);
    };
  });
  return raycast;
}

const Context = /*#__PURE__*/createContext({});
const useGizmoContext = () => {
  return useContext(Context);
};
const turnRate = 2 * Math.PI; // turn rate in angles per second

const dummy = new Object3D();
const matrix = new Matrix4();
const [q1, q2] = [new Quaternion(), new Quaternion()];
const target = new Vector3();
const targetPosition = new Vector3();
const targetQuaternion = new Quaternion();
const GizmoHelper = ({
  alignment = 'bottom-right',
  margin = [80, 80],
  onUpdate,
  onTarget,
  children: GizmoHelperComponent
}) => {
  const {
    gl,
    camera: mainCamera,
    size
  } = useThree();
  const gizmoRef = useRef();
  const virtualCam = useRef(null);
  const [virtualScene] = useState(() => new Scene());
  const animating = useRef(false);
  const radius = useRef(0);
  const focusPoint = useRef(new Vector3(0, 0, 0));

  const tweenCamera = direction => {
    animating.current = true;
    focusPoint.current = onTarget();
    radius.current = mainCamera.position.distanceTo(target); // Rotate from current camera orientation

    dummy.position.copy(target);
    dummy.lookAt(mainCamera.position);
    q1.copy(dummy.quaternion); // To new current camera orientation

    targetPosition.copy(direction).multiplyScalar(radius.current).add(target);
    dummy.lookAt(targetPosition);
    q2.copy(dummy.quaternion);
  };

  const animateStep = delta => {
    if (!animating.current) return;
    const step = delta * turnRate; // animate position by doing a slerp and then scaling the position on the unit sphere

    q1.rotateTowards(q2, step);
    mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current); // animate orientation

    mainCamera.quaternion.rotateTowards(targetQuaternion, step);
    mainCamera.updateProjectionMatrix();
    onUpdate && onUpdate();

    if (q1.angleTo(q2) < 0.01) {
      animating.current = false;
    }
  };

  const beforeRender = () => {
    var _gizmoRef$current;

    // Sync gizmo with main camera orientation
    matrix.copy(mainCamera.matrix).invert();
    (_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.quaternion.setFromRotationMatrix(matrix);
  };

  useFrame((_, delta) => {
    if (virtualCam.current && gizmoRef.current) {
      animateStep(delta);
      beforeRender();
      gl.autoClear = false;
      gl.clearDepth();
      gl.render(virtualScene, virtualCam.current);
    }
  });
  const gizmoHelperContext = {
    tweenCamera,
    raycast: useCamera(virtualCam)
  }; // Position gizmo component within scene

  const [marginX, marginY] = margin;
  const x = alignment.endsWith('-left') ? -size.width / 2 + marginX : size.width / 2 - marginX;
  const y = alignment.startsWith('top-') ? size.height / 2 - marginY : -size.height / 2 + marginY;
  return createPortal( /*#__PURE__*/createElement(Context.Provider, {
    value: gizmoHelperContext
  }, /*#__PURE__*/createElement(OrthographicCamera, {
    ref: virtualCam,
    makeDefault: false,
    position: [0, 0, 100]
  }), /*#__PURE__*/createElement("group", {
    ref: gizmoRef,
    position: [x, y, 0]
  }, GizmoHelperComponent)), virtualScene);
};

const faces = ['right', 'left', 'top', 'bottom', 'front', 'back'];

const makePositionVector = xyz => new Vector3(...xyz).multiplyScalar(0.38);

const corners = [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]].map(makePositionVector);
const cornerDimensions = [0.25, 0.25, 0.25];
const edges = [[1, 1, 0], [1, 0, 1], [1, 0, -1], [1, -1, 0], [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1], [-1, 1, 0], [-1, 0, 1], [-1, 0, -1], [-1, -1, 0]].map(makePositionVector);
const edgeDimensions = edges.map(edge => edge.toArray().map(axis => axis == 0 ? 0.5 : 0.25));

const FaceMaterial = ({
  hover,
  index
}) => {
  const texture = useMemo(() => {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const context = canvas.getContext('2d');
    context.fillStyle = '#eee';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.strokeStyle = '#444';
    context.strokeRect(0, 0, canvas.width, canvas.height);
    context.font = '28px Arial';
    context.textAlign = 'center';
    context.fillStyle = '#222';
    context.fillText(faces[index].toUpperCase(), 64, 76);
    return new CanvasTexture(canvas);
  }, [index]);
  return /*#__PURE__*/createElement("meshLambertMaterial", {
    map: texture,
    attachArray: "material",
    color: hover ? 'hotpink' : 'white'
  });
};

const FaceCube = () => {
  const {
    tweenCamera,
    raycast
  } = useGizmoContext();
  const [hover, setHover] = useState(null);

  const handlePointerOut = e => {
    setHover(null);
    e.stopPropagation();
  };

  const handlePointerDown = e => {
    tweenCamera(e.face.normal);
    e.stopPropagation();
  };

  const handlePointerMove = e => {
    setHover(Math.floor(e.faceIndex / 2));
    e.stopPropagation();
  };

  return /*#__PURE__*/createElement("mesh", {
    raycast: raycast,
    onPointerOut: handlePointerOut,
    onPointerMove: handlePointerMove,
    onPointerDown: handlePointerDown
  }, [...Array(6)].map((_, index) => /*#__PURE__*/createElement(FaceMaterial, {
    key: index,
    index: index,
    hover: hover === index
  })), /*#__PURE__*/createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [1, 1, 1]
  }));
};

const EdgeCube = ({
  dimensions,
  position
}) => {
  const {
    tweenCamera,
    raycast
  } = useGizmoContext();
  const [hover, setHover] = useState(false);

  const handlePointerOut = e => {
    setHover(false);
    e.stopPropagation();
  };

  const handlePointerOver = e => {
    setHover(true);
    e.stopPropagation();
  };

  const handlePointerDown = e => {
    tweenCamera(position);
    e.stopPropagation();
  };

  return /*#__PURE__*/createElement("mesh", {
    position: position,
    raycast: raycast,
    onPointerOver: handlePointerOver,
    onPointerOut: handlePointerOut,
    onPointerDown: handlePointerDown
  }, /*#__PURE__*/createElement("meshBasicMaterial", {
    color: hover ? 'hotpink' : 'white',
    transparent: true,
    opacity: 0.75,
    visible: hover
  }), /*#__PURE__*/createElement("boxBufferGeometry", {
    attach: "geometry",
    args: dimensions
  }));
};

const GizmoViewcube = () => {
  return /*#__PURE__*/createElement("group", {
    scale: [60, 60, 60]
  }, /*#__PURE__*/createElement(FaceCube, null), edges.map((edge, index) => /*#__PURE__*/createElement(EdgeCube, {
    key: index,
    position: edge,
    dimensions: edgeDimensions[index]
  })), corners.map((corner, index) => /*#__PURE__*/createElement(EdgeCube, {
    key: index,
    position: corner,
    dimensions: cornerDimensions
  })), /*#__PURE__*/createElement("ambientLight", {
    intensity: 0.5
  }), /*#__PURE__*/createElement("pointLight", {
    position: [10, 10, 10],
    intensity: 0.5
  }));
};

function Axis({
  color,
  rotation
}) {
  return /*#__PURE__*/createElement("group", {
    rotation: rotation
  }, /*#__PURE__*/createElement("mesh", {
    position: [0.4, 0, 0]
  }, /*#__PURE__*/createElement("boxGeometry", {
    args: [0.8, 0.05, 0.05]
  }), /*#__PURE__*/createElement("meshBasicMaterial", {
    color: color,
    toneMapped: false
  })));
}

function AxisHead(_ref) {
  let {
    arcStyle,
    label,
    labelColor
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["arcStyle", "label", "labelColor"]);

  const texture = useMemo(() => {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const context = canvas.getContext('2d');
    context.beginPath();
    context.arc(32, 32, 16, 0, 2 * Math.PI);
    context.closePath();
    context.fillStyle = arcStyle;
    context.fill();

    if (label) {
      context.font = '24px Arial';
      context.textAlign = 'center';
      context.fillStyle = labelColor;
      context.fillText(label, 32, 41);
    }

    return new CanvasTexture(canvas);
  }, [arcStyle, label, labelColor]);
  const [active, setActive] = useState(false);
  const scale = (label ? 1 : 0.75) * (active ? 1.2 : 1);

  const handlePointerOver = e => {
    setActive(true);
    e.stopPropagation();
  };

  const handlePointerOut = e => {
    setActive(false);
    e.stopPropagation();
  };

  return /*#__PURE__*/createElement("sprite", _extends({
    scale: [scale, scale, scale],
    onPointerOver: handlePointerOver,
    onPointerOut: handlePointerOut
  }, props), /*#__PURE__*/createElement("spriteMaterial", {
    map: texture,
    alphaTest: 0.3,
    opacity: label ? 1 : 0.75,
    toneMapped: false
  }));
}

const GizmoViewport = (_ref2) => {
  let {
    axisColors = ['#ff3653', '#8adb00', '#2c8fff'],
    labelColor = '#000'
  } = _ref2,
      props = _objectWithoutPropertiesLoose(_ref2, ["axisColors", "labelColor"]);

  const [colorX, colorY, colorZ] = axisColors;
  const {
    tweenCamera,
    raycast
  } = useGizmoContext();
  const axisHeadProps = {
    labelColor,
    onPointerDown: e => {
      tweenCamera(e.object.position);
      e.stopPropagation();
    },
    raycast
  };
  return /*#__PURE__*/createElement("group", _extends({
    scale: [40, 40, 40]
  }, props), /*#__PURE__*/createElement(Axis, {
    color: colorX,
    rotation: [0, 0, 0]
  }), /*#__PURE__*/createElement(Axis, {
    color: colorY,
    rotation: [0, 0, Math.PI / 2]
  }), /*#__PURE__*/createElement(Axis, {
    color: colorZ,
    rotation: [0, -Math.PI / 2, 0]
  }), /*#__PURE__*/createElement(AxisHead, _extends({
    arcStyle: colorX,
    position: [1, 0, 0],
    label: "X"
  }, axisHeadProps)), /*#__PURE__*/createElement(AxisHead, _extends({
    arcStyle: colorY,
    position: [0, 1, 0],
    label: "Y"
  }, axisHeadProps)), /*#__PURE__*/createElement(AxisHead, _extends({
    arcStyle: colorZ,
    position: [0, 0, 1],
    label: "Z"
  }, axisHeadProps)), /*#__PURE__*/createElement(AxisHead, _extends({
    arcStyle: colorX,
    position: [-1, 0, 0]
  }, axisHeadProps)), /*#__PURE__*/createElement(AxisHead, _extends({
    arcStyle: colorY,
    position: [0, -1, 0]
  }, axisHeadProps)), /*#__PURE__*/createElement(AxisHead, _extends({
    arcStyle: colorZ,
    position: [0, 0, -1]
  }, axisHeadProps)), /*#__PURE__*/createElement("ambientLight", {
    intensity: 0.5
  }), /*#__PURE__*/createElement("pointLight", {
    position: [10, 10, 10],
    intensity: 0.5
  }));
};

function useCubeTexture(files, {
  path
}) {
  // @ts-ignore
  const [cubeTexture] = useLoader( // @ts-ignore
  CubeTextureLoader, [files], loader => loader.setPath(path));
  return cubeTexture;
}

useCubeTexture.preload = (files, {
  path
}) => useLoader.preload( // @ts-ignore
CubeTextureLoader, [files], loader => loader.setPath(path));

function useFBX(path) {
  return useLoader(FBXLoader, path);
}

useFBX.preload = path => useLoader.preload(FBXLoader, path);

function extensions(useDraco, useMeshopt) {
  return loader => {
    if (useDraco) {
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : 'https://www.gstatic.com/draco/v1/decoders/');
      loader.setDRACOLoader(dracoLoader);
    }

    if (useMeshopt) {
      loader.setMeshoptDecoder(MeshoptDecoder);
    }
  };
}

function useGLTF(path, useDraco = true, useMeshOpt = true) {
  const gltf = useLoader(GLTFLoader, path, extensions(useDraco, useMeshOpt));
  return gltf;
}

useGLTF.preload = (path, useDraco = true, useMeshOpt = true) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshOpt));

let saveLastTotalLoaded = 0;
const useProgress = create$1(set => {
  DefaultLoadingManager.onStart = (item, loaded, total) => {
    set({
      active: true,
      item,
      loaded,
      total,
      progress: (loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100
    });
  };

  DefaultLoadingManager.onLoad = () => set({
    active: false
  });

  DefaultLoadingManager.onError = item => set(state => ({
    errors: [...state.errors, item]
  }));

  DefaultLoadingManager.onProgress = (item, loaded, total) => {
    if (loaded === total) {
      saveLastTotalLoaded = total;
    }

    set({
      item,
      loaded,
      total,
      progress: (loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100 || 100
    });
  };

  return {
    errors: [],
    active: false,
    progress: 0,
    item: '',
    loaded: 0,
    total: 0
  };
});

let _inverseMatrix = new Matrix4();

let _ray = new Ray();

let _sphere = new Sphere$1();

let _vA = new Vector3();

function meshBounds(raycaster, intersects) {
  let geometry = this.geometry;
  let material = this.material;
  let matrixWorld = this.matrixWorld;
  if (material === undefined) return; // Checking boundingSphere distance to ray

  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

  _sphere.copy(geometry.boundingSphere);

  _sphere.applyMatrix4(matrixWorld);

  if (raycaster.ray.intersectsSphere(_sphere) === false) return;

  _inverseMatrix.copy(matrixWorld).invert();

  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;
  intersects.push({
    distance: _vA.distanceTo(raycaster.ray.origin),
    point: _vA.clone(),
    object: this
  });
}

extend({
  MeshReflectorMaterial
});
const Reflector = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    mixBlur = 0.0,
    mixStrength = 0.5,
    resolution = 256,
    blur = [0, 0],
    args = [1, 1],
    minDepthThreshold = 0.9,
    maxDepthThreshold = 1,
    depthScale = 0,
    depthToBlurRatioBias = 0.25,
    mirror,
    children,
    debug = 0,
    distortion = 1,
    distortionMap
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["mixBlur", "mixStrength", "resolution", "blur", "args", "minDepthThreshold", "maxDepthThreshold", "depthScale", "depthToBlurRatioBias", "mirror", "children", "debug", "distortion", "distortionMap"]);

  blur = Array.isArray(blur) ? blur : [blur, blur];
  const hasBlur = blur[0] + blur[1] > 0;
  const meshRef = useRef(null);
  const [reflectorPlane] = useState(() => new Plane$1());
  const [normal] = useState(() => new Vector3());
  const [reflectorWorldPosition] = useState(() => new Vector3());
  const [cameraWorldPosition] = useState(() => new Vector3());
  const [rotationMatrix] = useState(() => new Matrix4());
  const [lookAtPosition] = useState(() => new Vector3(0, 0, -1));
  const [clipPlane] = useState(() => new Vector4());
  const [view] = useState(() => new Vector3());
  const [target] = useState(() => new Vector3());
  const [q] = useState(() => new Vector4());
  const [textureMatrix] = useState(() => new Matrix4());
  const [virtualCamera] = useState(() => new PerspectiveCamera$1());
  const {
    gl,
    scene,
    camera
  } = useThree();
  const beforeRender = useCallback(() => {
    reflectorWorldPosition.setFromMatrixPosition(meshRef.current.matrixWorld);
    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    rotationMatrix.extractRotation(meshRef.current.matrixWorld);
    normal.set(0, 0, 1);
    normal.applyMatrix4(rotationMatrix);
    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away

    if (view.dot(normal) > 0) return;
    view.reflect(normal).negate();
    view.add(reflectorWorldPosition);
    rotationMatrix.extractRotation(camera.matrixWorld);
    lookAtPosition.set(0, 0, -1);
    lookAtPosition.applyMatrix4(rotationMatrix);
    lookAtPosition.add(cameraWorldPosition);
    target.subVectors(reflectorWorldPosition, lookAtPosition);
    target.reflect(normal).negate();
    target.add(reflectorWorldPosition);
    virtualCamera.position.copy(view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(rotationMatrix);
    virtualCamera.up.reflect(normal);
    virtualCamera.lookAt(target);
    virtualCamera.far = camera.far; // Used in WebGLBackground

    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix

    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    textureMatrix.multiply(virtualCamera.projectionMatrix);
    textureMatrix.multiply(virtualCamera.matrixWorldInverse);
    textureMatrix.multiply(meshRef.current.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf

    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    q.z = -1.0;
    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector

    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix

    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z + 1.0;
    projectionMatrix.elements[14] = clipPlane.w; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const [fbo1, fbo2, blurpass, reflectorProps] = useMemo(() => {
    const parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBFormat,
      encoding: gl.outputEncoding
    };
    const fbo1 = new WebGLRenderTarget(resolution, resolution, parameters);
    fbo1.depthBuffer = true;
    fbo1.depthTexture = new DepthTexture(resolution, resolution);
    fbo1.depthTexture.format = DepthFormat;
    fbo1.depthTexture.type = UnsignedShortType;
    const fbo2 = new WebGLRenderTarget(resolution, resolution, parameters);
    const blurpass = new BlurPass({
      gl,
      resolution,
      width: blur[0],
      height: blur[1],
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias
    });
    const reflectorProps = {
      mirror,
      textureMatrix,
      mixBlur,
      tDiffuse: fbo1.texture,
      tDepth: fbo1.depthTexture,
      tDiffuseBlur: fbo2.texture,
      hasBlur,
      mixStrength,
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias,
      transparent: true,
      debug,
      distortion,
      distortionMap,
      'defines-USE_BLUR': hasBlur ? '' : undefined,
      'defines-USE_DEPTH': depthScale > 0 ? '' : undefined,
      'defines-USE_DISTORTION': !!distortionMap ? '' : undefined
    };
    return [fbo1, fbo2, blurpass, reflectorProps];
  }, [gl, blur, textureMatrix, resolution, mirror, hasBlur, mixBlur, mixStrength, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, debug, distortion, distortionMap]);
  useFrame(() => {
    if (!(meshRef == null ? void 0 : meshRef.current)) return;
    meshRef.current.visible = false;
    beforeRender();
    gl.setRenderTarget(fbo1);
    gl.render(scene, virtualCamera);
    if (hasBlur) blurpass.render(gl, fbo1, fbo2);
    meshRef.current.visible = true;
    gl.setRenderTarget(null);
  });
  return /*#__PURE__*/createElement("mesh", _extends({
    ref: mergeRefs([meshRef, ref])
  }, props), /*#__PURE__*/createElement("planeBufferGeometry", {
    args: args
  }), children ? children('meshReflectorMaterial', reflectorProps) : /*#__PURE__*/createElement("meshReflectorMaterial", reflectorProps));
});

const Shadow = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    fog = false,
    colorStop = 0.0,
    color = 'black',
    opacity = 0.5
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["fog", "colorStop", "color", "opacity"]);

  const canvas = useMemo(() => {
    let canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    let context = canvas.getContext('2d');
    let gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
    gradient.addColorStop(colorStop, new Color(color).getStyle());
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas.width, canvas.height);
    return canvas;
  }, [color, colorStop]);
  return /*#__PURE__*/createElement("mesh", _extends({
    ref: ref
  }, props), /*#__PURE__*/createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [1, 1]
  }), /*#__PURE__*/createElement("meshBasicMaterial", {
    attach: "material",
    transparent: true,
    opacity: opacity,
    fog: fog
  }, /*#__PURE__*/createElement("canvasTexture", {
    attach: "map",
    args: [canvas]
  })));
});

function Stats({
  showPanel = 0,
  className,
  parent
}) {
  const stats = useEffectfulState(() => new StatsImpl(), []);
  useEffect(() => {
    if (stats) {
      const node = parent && parent.current || document.body;
      stats.showPanel(showPanel);
      node == null ? void 0 : node.appendChild(stats.dom);
      if (className) stats.dom.classList.add(className);
      const begin = addEffect(() => stats.begin());
      const end = addAfterEffect(() => stats.end());
      return () => {
        node == null ? void 0 : node.removeChild(stats.dom);
        begin();
        end();
      };
    }
  }, [parent, stats, className, showPanel]);
  return null;
}

const Center = /*#__PURE__*/forwardRef(function Center(_ref, ref) {
  let {
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const outer = useRef();
  const inner = useRef();
  useLayoutEffect(() => {
    if (inner.current && outer.current) {
      const box = new Box3();
      box.setFromObject(inner.current);
      const center = new Vector3();
      box.getSize(center);
      outer.current.position.set(-center.x / 2, -center.y / 2, -center.z / 2);
    }
  }, [children]);
  return /*#__PURE__*/createElement("group", _extends({
    ref: ref
  }, props), /*#__PURE__*/createElement("group", {
    ref: outer
  }, /*#__PURE__*/createElement("group", {
    ref: inner
  }, children)));
});

function Preload({
  all,
  scene,
  camera
}) {
  const {
    gl,
    scene: dScene,
    camera: dCamera
  } = useThree(); // Layout effect because it must run before React commits

  useLayoutEffect(() => {
    const invisible = [];

    if (all) {
      (scene || dScene).traverse(object => {
        if (object.visible === false) {
          invisible.push(object);
          object.visible = true;
        }
      });
    } // Now compile the scene


    gl.compile(scene || dScene, camera || dCamera); // Flips these objects back

    invisible.forEach(object => object.visible = false); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return null;
}

function useAspect(type, width, height, factor = 1) {
  const {
    viewport: v,
    aspect
  } = useThree();
  const adaptedHeight = height * (aspect > width / height ? v.width / width : v.height / height);
  const adaptedWidth = width * (aspect > width / height ? v.width / width : v.height / height);
  return [adaptedWidth * factor, adaptedHeight * factor, 1];
}

function useDetectGPU(props) {
  const [GPUTier, setGPUTier] = useState(null);
  useEffect(() => {
    getGPUTier(props).then(result => setGPUTier(result));
  }, [props]);
  return GPUTier;
}

function useHelper(object3D, proto, ...args) {
  const helper = useRef();
  const {
    scene
  } = useThree();
  useEffect(() => {
    if (proto && object3D.current) {
      helper.current = new proto(object3D.current, ...args);

      if (helper.current) {
        scene.add(helper.current);
      }
    }

    return () => {
      if (helper.current) {
        scene.remove(helper.current);
      }
    };
  }, [scene, proto, object3D, args]);
  useFrame(() => {
    if (helper.current) {
      helper.current.update();
    }
  });
  return helper;
}

/* eslint-disable react-hooks/rules-of-hooks */
function useContextBridge(...contexts) {
  const cRef = useRef([]);
  cRef.current = contexts.map(context => useContext(context));
  return useMemo(() => ({
    children
  }) => contexts.reduceRight((acc, Context, i) => /*#__PURE__*/createElement(Context.Provider, {
    value: cRef.current[i],
    children: acc
  }), children
  /*
   * done this way in reference to:
   * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/44572#issuecomment-625878049
   * https://github.com/microsoft/TypeScript/issues/14729
   */
  ), []);
}

function useAnimations(clips, root) {
  const ref = useRef();
  const actualRef = root ? root : ref;
  const [mixer] = useState(() => new AnimationMixer(undefined));
  const api = useMemo(() => ({
    ref: actualRef,
    clips,
    actions: clips.reduce((prev, clip) => _extends({}, prev, {
      [clip.name]: null
    }), {}),
    names: clips.map(clip => clip.name),
    mixer
  }), [clips, mixer, actualRef]);
  useFrame((state, delta) => mixer.update(delta));
  useEffect(() => {
    const currentRoot = actualRef.current;

    if (currentRoot) {
      clips.forEach(clip => api.actions[clip.name] = mixer.clipAction(clip, currentRoot));
    }

    return () => Object.values(api.actions).forEach(action => {
      if (currentRoot) {
        mixer.uncacheAction(action, currentRoot);
      }
    });
  }, [api, clips, mixer, root, actualRef]);
  return api;
}

//  uncomment when TS version supports function overloads
// export function useFBO(settings?: FBOSettings)
function useFBO(width, height, settings) {
  const {
    size,
    gl
  } = useThree();
  const dpr = useMemo(() => gl.getPixelRatio(), [gl]);

  const _width = typeof width === 'number' ? width : size.width * dpr;

  const _height = typeof height === 'number' ? height : size.height * dpr;

  const _settings = (typeof width === 'number' ? settings : width) || {};

  const target = useMemo(() => {
    const {
      multisample,
      samples
    } = _settings,
          targetSettings = _objectWithoutPropertiesLoose(_settings, ["multisample", "samples"]);

    let target;

    if (multisample && gl.capabilities.isWebGL2) {
      target = new WebGLMultisampleRenderTarget(_width, _height, targetSettings);
      if (samples) target.samples = samples;
    } else {
      target = new WebGLRenderTarget(_width, _height, targetSettings);
    }

    return target; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useEffect(() => {
    target.setSize(_width, _height);
  }, [target, _width, _height]);
  useEffect(() => {
    return () => target.dispose(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return target;
}

function useSimplification(simplePercent) {
  const ref = useRef();
  const original = useRef();
  const modifier = useRef();
  useEffect(() => {
    if (!original.current) {
      original.current = ref.current.geometry.clone();
      modifier.current = new SimplifyModifier();
    }
  }, []);
  useEffect(() => {
    if (original.current && ref.current) {
      let geometry = new BufferGeometry();
      geometry = original.current.clone();
      const count = Math.floor(geometry.attributes.position.count * simplePercent); // number of vertices to remove

      ref.current.geometry = modifier.current.modify(geometry, count);
    }
  }, [simplePercent]);
  return ref;
}

function useTessellation(passes = 3, maxEdgeLength) {
  const ref = useRef();
  const original = useRef();
  const modifier = useRef();
  useEffect(() => {
    if (!original.current) {
      original.current = ref.current.geometry.clone();
      modifier.current = new TessellateModifier(parseInt(maxEdgeLength), passes);
    }
  }, [maxEdgeLength, passes]);
  useEffect(() => {
    modifier.current.maxEdgeLength = maxEdgeLength;
  }, [maxEdgeLength]);
  useEffect(() => {
    if (original.current && ref.current) {
      let geometry = new BufferGeometry();
      geometry = original.current.clone();
      geometry = modifier.current.modify(geometry);
      ref.current.geometry = geometry;
    }
  }, [maxEdgeLength, passes]);
  return ref;
}

function useEdgeSplit(cutOffAngle, tryKeepNormals = true) {
  const ref = useRef();
  const original = useRef();
  const modifier = useRef();
  useEffect(() => {
    if (!original.current && ref.current) {
      original.current = ref.current.geometry.clone();
      modifier.current = new EdgeSplitModifier();
    }
  }, []);
  useEffect(() => {
    if (original.current && ref.current && modifier.current) {
      let geometry = new BufferGeometry();
      geometry = original.current.clone();
      const modifiedGeometry = modifier.current.modify(geometry, cutOffAngle, tryKeepNormals);
      modifiedGeometry.computeVertexNormals();
      ref.current.geometry = modifiedGeometry;
    }
  }, [cutOffAngle, tryKeepNormals]);
  return ref;
}

const CurveModifier = /*#__PURE__*/forwardRef(({
  children,
  curve
}, ref) => {
  const [object3D, setObj] = useState();
  const original = useRef();
  const modifier = useRef();
  useImperativeHandle(ref, () => ({
    moveAlongCurve: val => {
      var _modifier$current;

      (_modifier$current = modifier.current) == null ? void 0 : _modifier$current.moveAlongCurve(val);
    }
  }));
  useEffect(() => {
    if (!modifier.current && original.current && ref) {
      modifier.current = new Flow(original.current);
      setObj(modifier.current.object3D);
    }
  }, [children, ref]);
  useEffect(() => {
    if (original.current && curve) {
      var _modifier$current2;

      (_modifier$current2 = modifier.current) == null ? void 0 : _modifier$current2.updateCurve(0, curve);
    }
  }, [curve]);
  return object3D ? /*#__PURE__*/createElement("primitive", {
    object: object3D
  }) : /*#__PURE__*/cloneElement(Children.only(children), {
    ref: original
  });
});

var distort = "#define GLSLIFY 1\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}"; // eslint-disable-line

class DistortMaterialImpl extends MeshPhysicalMaterial {
  constructor(parameters = {}) {
    super(parameters);

    _defineProperty(this, "_time", void 0);

    _defineProperty(this, "_distort", void 0);

    _defineProperty(this, "_radius", void 0);

    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._distort = {
      value: 0.4
    };
    this._radius = {
      value: 1
    };
  }

  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.radius = this._radius;
    shader.uniforms.distort = this._distort;
    shader.vertexShader = "\n      uniform float time;\n      uniform float radius;\n      uniform float distort;\n      " + distort + "\n      " + shader.vertexShader + "\n    ";
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "\n        float updateTime = time / 50.0;\n        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));\n        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));\n        ");
  }

  get time() {
    return this._time.value;
  }

  set time(v) {
    this._time.value = v;
  }

  get distort() {
    return this._distort.value;
  }

  set distort(v) {
    this._distort.value = v;
  }

  get radius() {
    return this._radius.value;
  }

  set radius(v) {
    this._radius.value = v;
  }

}

const MeshDistortMaterial = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    speed = 1
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  const [material] = useState(() => new DistortMaterialImpl());
  useFrame(state => material && (material.time = state.clock.getElapsedTime() * speed));
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: material,
    ref: ref,
    attach: "material"
  }, props));
});

class WobbleMaterialImpl extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);

    _defineProperty(this, "_time", void 0);

    _defineProperty(this, "_factor", void 0);

    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._factor = {
      value: 1
    };
  }

  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.factor = this._factor;
    shader.vertexShader = "\n      uniform float time;\n      uniform float factor;\n      " + shader.vertexShader + "\n    ";
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "float theta = sin( time + position.y ) / 2.0 * factor;\n        float c = cos( theta );\n        float s = sin( theta );\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n        vec3 transformed = vec3( position ) * m;\n        vNormal = vNormal * m;");
  }

  get time() {
    return this._time.value;
  }

  set time(v) {
    this._time.value = v;
  }

  get factor() {
    return this._factor.value;
  }

  set factor(v) {
    this._factor.value = v;
  }

}

const MeshWobbleMaterial = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    speed = 1
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  const [material] = useState(() => new WobbleMaterialImpl());
  useFrame(state => material && (material.time = state.clock.getElapsedTime() * speed));
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: material,
    ref: ref,
    attach: "material"
  }, props));
});

function shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {
  return class extends ShaderMaterial {
    constructor() {
      const entries = Object.entries(uniforms); // Create unforms and shaders

      super({
        uniforms: entries.reduce((acc, [name, value]) => {
          const uniform = UniformsUtils.clone({
            [name]: {
              value
            }
          });
          return _extends({}, acc, uniform);
        }, {}),
        vertexShader,
        fragmentShader
      }); // Create getter/setters

      entries.forEach(([name]) => Object.defineProperty(this, name, {
        get: () => this.uniforms[name].value,
        set: v => this.uniforms[name].value = v
      }));
      if (onInit) onInit(this);
    }

  };
}

function calcPosFromAngles(inclination, azimuth, vector = new Vector3()) {
  const theta = Math.PI * (inclination - 0.5);
  const phi = 2 * Math.PI * (azimuth - 0.5);
  vector.x = Math.cos(phi);
  vector.y = Math.sin(theta);
  vector.z = Math.sin(phi);
  return vector;
}
const Sky = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    inclination = 0,
    azimuth = 0.25,
    distance = 100,
    mieCoefficient = 0.005,
    mieDirectionalG = 0.8,
    rayleigh = 1,
    turbidity = 2,
    sunPosition = calcPosFromAngles(inclination, azimuth)
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["inclination", "azimuth", "distance", "mieCoefficient", "mieDirectionalG", "rayleigh", "turbidity", "sunPosition"]);

  const scale = useMemo(() => new Vector3().setScalar(distance), [distance]);
  const [sky] = useState(() => new Sky$1());
  return /*#__PURE__*/createElement("primitive", _extends({
    dispose: undefined,
    object: sky,
    ref: ref,
    "material-uniforms-mieCoefficient-value": mieCoefficient,
    "material-uniforms-mieDirectionalG-value": mieDirectionalG,
    "material-uniforms-rayleigh-value": rayleigh,
    "material-uniforms-sunPosition-value": sunPosition,
    "material-uniforms-turbidity-value": turbidity,
    scale: scale
  }, props));
});

const pcss = ({
  frustrum,
  frustum = 3.75,
  size = 0.005,
  near = 9.5,
  samples = 17,
  rings = 11
} = {}) => "#define LIGHT_WORLD_SIZE " + size + "\n#define LIGHT_FRUSTUM_WIDTH " + (frustrum != null ? frustrum : frustum) + "\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE " + near + "\n\n#define NUM_SAMPLES " + samples + "\n#define NUM_RINGS " + rings + "\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n#define PCF_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples(const in vec2 randomSeed) {\n\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n\tfloat angle = rand(randomSeed) * PI2;\n\tfloat radius = INV_NUM_SAMPLES;\n\tfloat radiusStep = radius;\n\tfor (int i = 0; i < NUM_SAMPLES; i++) {\n\t\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t}\n}\n\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\n\treturn (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\n\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\n\tfloat blockerDepthSum = 0.0;\n\tint numBlockers = 0;\n\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\n\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\tif (shadowMapDepth < zReceiver) {\n\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\tnumBlockers++;\n\t\t}\n\t}\n\tif (numBlockers == 0) return -1.0;\n\treturn blockerDepthSum / float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\n}\n\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\n\tvec2 uv = coords.xy;\n\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\tinitPoissonSamples(uv);\n\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n\tif (avgBlockerDepth == -1.0) return 1.0;\n\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}";

let deployed = false;
const softShadows = props => {
  // Avoid adding the effect twice, which may happen in HMR scenarios
  if (!deployed) {
    if (props == null ? void 0 : props.frustrum) {
      console.warn('You have used an incorrect spelling of frustrum, this will be deprecated in the future');
    }

    deployed = true;
    let shader = ShaderChunk.shadowmap_pars_fragment;
    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\n' + pcss(_extends({}, props)));
    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )');
    ShaderChunk.shadowmap_pars_fragment = shader;
  }
};

class StarfieldMaterial extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        time: {
          value: 0.0
        },
        fade: {
          value: 1.0
        }
      },
      vertexShader: "uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }",
      fragmentShader: "uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n      }"
    });
  }

}

const genStar = r => {
  return new Vector3().setFromSpherical(new Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};

const Stars = /*#__PURE__*/forwardRef(({
  radius = 100,
  depth = 50,
  count = 5000,
  saturation = 0,
  factor = 4,
  fade = false
}, ref) => {
  const material = useRef();
  const [position, color, size] = useMemo(() => {
    const positions = [];
    const colors = [];
    const sizes = Array.from({
      length: count
    }, () => (0.5 + 0.5 * Math.random()) * factor);
    const color = new Color();
    let r = radius + depth;
    const increment = depth / count;

    for (let i = 0; i < count; i++) {
      r -= increment * Math.random();
      positions.push(...genStar(r).toArray());
      color.setHSL(i / count, saturation, 0.9);
      colors.push(color.r, color.g, color.b);
    }

    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];
  }, [count, depth, factor, radius, saturation]);
  useFrame(state => material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime()));
  const [starfieldMaterial] = useState(() => new StarfieldMaterial());
  return /*#__PURE__*/createElement("points", {
    ref: ref
  }, /*#__PURE__*/createElement("bufferGeometry", {
    attach: "geometry"
  }, /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'position'],
    args: [position, 3]
  }), /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'color'],
    args: [color, 3]
  }), /*#__PURE__*/createElement("bufferAttribute", {
    attachObject: ['attributes', 'size'],
    args: [size, 1]
  })), /*#__PURE__*/createElement("primitive", {
    dispose: undefined,
    ref: material,
    object: starfieldMaterial,
    attach: "material",
    blending: AdditiveBlending,
    "uniforms-fade-value": fade,
    transparent: true,
    vertexColors: true
  }));
});

const ContactShadows = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    opacity = 1,
    width = 1,
    height = 1,
    blur = 1,
    far = 10,
    resolution = 256
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["opacity", "width", "height", "blur", "far", "resolution"]);

  const {
    scene,
    gl
  } = useThree();
  const shadowCamera = useRef();
  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = useMemo(() => {
    const renderTarget = new WebGLRenderTarget(resolution, resolution);
    const renderTargetBlur = new WebGLRenderTarget(resolution, resolution);
    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;
    const planeGeometry = new PlaneBufferGeometry(width, height).rotateX(Math.PI / 2);
    const blurPlane = new Mesh(planeGeometry);
    const depthMaterial = new MeshDepthMaterial();
    depthMaterial.depthTest = depthMaterial.depthWrite = false;

    depthMaterial.onBeforeCompile = shader => shader.fragmentShader = shader.fragmentShader.replace('1.0 - fragCoordZ ), opacity );', '0.0 ), ( 1.0 - fragCoordZ ) * 1.0 );');

    const horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);
    const verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);
    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;
    return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];
  }, [resolution, width, height]);
  useFrame(() => {
    if (shadowCamera.current) {
      const initialBackground = scene.background;
      scene.background = null;
      scene.overrideMaterial = depthMaterial;
      gl.setRenderTarget(renderTarget);
      gl.render(scene, shadowCamera.current);
      scene.overrideMaterial = null;
      blurPlane.material = horizontalBlurMaterial;
      blurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;
      horizontalBlurMaterial.uniforms.h.value = blur / 256;
      gl.setRenderTarget(renderTargetBlur);
      gl.render(blurPlane, shadowCamera.current);
      blurPlane.material = verticalBlurMaterial;
      blurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;
      verticalBlurMaterial.uniforms.v.value = blur / 256;
      gl.setRenderTarget(renderTarget);
      gl.render(blurPlane, shadowCamera.current);
      gl.setRenderTarget(null);
      scene.background = initialBackground;
    }
  });
  return /*#__PURE__*/createElement("group", _extends({}, props, {
    ref: ref
  }), /*#__PURE__*/createElement("mesh", {
    geometry: planeGeometry,
    scale: [1, -1, 1],
    rotation: [-Math.PI / 2, 0, 0]
  }, /*#__PURE__*/createElement("meshBasicMaterial", {
    map: renderTarget.texture,
    transparent: true,
    opacity: opacity
  })), /*#__PURE__*/createElement("orthographicCamera", {
    ref: shadowCamera,
    args: [-width / 2, width / 2, height / 2, -height / 2, 0, far]
  }));
});

const eps = 0.00001;

function createShape(width, height, radius0) {
  const shape = new Shape();
  const radius = radius0 - eps;
  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
  shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);
  shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);
  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);
  return shape;
}

const RoundedBox = /*#__PURE__*/forwardRef(function RoundedBox(_ref, ref) {
  let {
    args: [width = 1, height = 1, depth = 1] = [],
    radius = 0.05,
    smoothness = 4,
    children
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["args", "radius", "smoothness", "children"]);

  const shape = useMemo(() => createShape(width, height, radius), [width, height, radius]);
  const params = useMemo(() => ({
    depth: depth - radius * 2,
    bevelEnabled: true,
    bevelSegments: smoothness * 2,
    steps: 1,
    bevelSize: radius - eps,
    bevelThickness: radius,
    curveSegments: smoothness
  }), [depth, radius, smoothness]);
  const geomRef = useUpdate(geometry => void geometry.center(), [shape, params]);
  return /*#__PURE__*/createElement("mesh", _extends({
    ref: ref
  }, rest), /*#__PURE__*/createElement("extrudeBufferGeometry", {
    attach: "geometry",
    ref: geomRef,
    args: [shape, params]
  }), children);
});

function createScreenQuadGeometry() {
  const geometry = new BufferGeometry();
  const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
  geometry.setAttribute('position', new BufferAttribute(vertices, 2));
  return geometry;
}

const ScreenQuad = /*#__PURE__*/forwardRef(function ScreenQuad(_ref, ref) {
  let {
    children
  } = _ref,
      restProps = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const geometry = useMemo(createScreenQuadGeometry, []);
  return /*#__PURE__*/createElement("mesh", _extends({
    ref: ref,
    geometry: geometry,
    frustumCulled: false
  }, restProps), children);
});

function getFormatString(format) {
  switch (format) {
    case 64:
      return '-64px';

    case 128:
      return '-128px';

    case 256:
      return '-256px';

    case 512:
      return '-512px';

    default:
      return '';
  }
}

const MATCAP_ROOT = 'https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d';
const DEFAULT_MATCAP = matcapList[0];
function useMatcapTexture(id = 0, format = 1024) {
  const numTot = useMemo(() => Object.keys(matcapList).length, []);
  const fileHash = useMemo(() => {
    if (typeof id === 'string') {
      return id;
    } else if (typeof id === 'number') {
      return matcapList[id];
    }

    return null;
  }, [id]);
  const fileName = "" + (fileHash || DEFAULT_MATCAP) + getFormatString(format) + ".png";
  const url = MATCAP_ROOT + "/" + format + "/" + fileName;
  const matcapTexture = useTexture(url);
  return [matcapTexture, url, numTot];
}

const NORMAL_ROOT = 'https://rawcdn.githack.com/emmelleppi/normal-maps/f24c810fc1d86b5b1e5dfea914b668f70b5f2923';
const DEFAULT_NORMAL = normalsList[0];
function useNormalTexture(id = 0, settings = {}) {
  const {
    repeat = [1, 1],
    anisotropy = 1,
    offset = [0, 0]
  } = settings;
  const numTot = useMemo(() => Object.keys(normalsList).length, []);
  const imageName = normalsList[id] || DEFAULT_NORMAL;
  const url = NORMAL_ROOT + "/normals/" + imageName;
  const normalTexture = useTexture(url);
  useEffect(() => {
    if (!normalTexture) return;
    normalTexture.wrapS = normalTexture.wrapT = RepeatWrapping;
    normalTexture.repeat = new Vector2(repeat[0], repeat[1]);
    normalTexture.offset = new Vector2(offset[0], offset[1]);
    normalTexture.anisotropy = anisotropy;
  }, [normalTexture, anisotropy, repeat, offset]);
  return [normalTexture, url, numTot];
}

export { softShadows as $, useHelper as A, Billboard as B, Cloud as C, Detailed as D, Environment as E, FlyControls as F, GizmoHelper as G, useContextBridge as H, useAnimations as I, useFBO as J, useSimplification as K, Line as L, MapControls as M, useTessellation as N, OrthographicCamera as O, PositionalAudio as P, QuadraticBezierLine as Q, Reflector as R, Shadow as S, Text as T, useEdgeSplit as U, CurveModifier as V, MeshDistortMaterial as W, MeshWobbleMaterial as X, shaderMaterial as Y, calcPosFromAngles as Z, Sky as _, CubicBezierLine as a, Stars as a0, ContactShadows as a1, Box as a2, Circle as a3, Cone as a4, Cylinder as a5, Sphere as a6, Plane as a7, Tube as a8, Torus as a9, TorusKnot as aa, Tetrahedron as ab, Ring as ac, Polyhedron as ad, Icosahedron as ae, Octahedron as af, Dodecahedron as ag, Extrude as ah, Lathe as ai, Parametric as aj, RoundedBox as ak, ScreenQuad as al, useMatcapTexture as am, useNormalTexture as an, Effects as b, PerspectiveCamera as c, CameraShake as d, CubeCamera as e, DeviceOrientationControls as f, OrbitControls as g, TrackballControls as h, isWebGL2Available as i, TransformControls as j, PointerLockControls as k, GizmoViewcube as l, GizmoViewport as m, useCubeTexture as n, useFBX as o, useGLTF as p, useProgress as q, useTexture as r, meshBounds as s, Stats as t, useGizmoContext as u, Center as v, Preload as w, useAspect as x, useCamera as y, useDetectGPU as z };
