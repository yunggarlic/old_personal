import 'blob-polyfill';
import '../helpers/base64.js';
import '../assets/cloud.base64.js';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { forwardRef, useState, useRef, useEffect, useMemo, useLayoutEffect, createElement } from 'react';
import { useThree, useFrame } from 'react-three-fiber';
import { q as useProgress } from '../useNormalTexture-34932e21.js';
export { B as Billboard, a2 as Box, d as CameraShake, v as Center, a3 as Circle, C as Cloud, a4 as Cone, a1 as ContactShadows, e as CubeCamera, a as CubicBezierLine, V as CurveModifier, a5 as Cylinder, D as Detailed, f as DeviceOrientationControls, ag as Dodecahedron, b as Effects, E as Environment, ah as Extrude, F as FlyControls, G as GizmoHelper, l as GizmoViewcube, m as GizmoViewport, ae as Icosahedron, ai as Lathe, L as Line, M as MapControls, W as MeshDistortMaterial, X as MeshWobbleMaterial, af as Octahedron, g as OrbitControls, O as OrthographicCamera, aj as Parametric, c as PerspectiveCamera, a7 as Plane, k as PointerLockControls, ad as Polyhedron, P as PositionalAudio, w as Preload, Q as QuadraticBezierLine, R as Reflector, ac as Ring, ak as RoundedBox, al as ScreenQuad, S as Shadow, _ as Sky, a6 as Sphere, a0 as Stars, t as Stats, ab as Tetrahedron, T as Text, a9 as Torus, aa as TorusKnot, h as TrackballControls, j as TransformControls, a8 as Tube, Z as calcPosFromAngles, i as isWebGL2Available, s as meshBounds, Y as shaderMaterial, $ as softShadows, I as useAnimations, x as useAspect, y as useCamera, H as useContextBridge, n as useCubeTexture, z as useDetectGPU, U as useEdgeSplit, J as useFBO, o as useFBX, p as useGLTF, u as useGizmoContext, A as useHelper, am as useMatcapTexture, an as useNormalTexture, q as useProgress, K as useSimplification, N as useTessellation, r as useTexture } from '../useNormalTexture-34932e21.js';
import 'react-merge-refs';
import { Vector3, OrthographicCamera, PerspectiveCamera } from 'three';
import 'three/examples/jsm/lines/LineGeometry';
import 'three/examples/jsm/lines/LineMaterial';
import 'three/examples/jsm/lines/Line2';
import 'troika-three-text';
import 'three/examples/jsm/loaders/RGBELoader';
import 'use-asset';
import '../helpers/environment-assets.js';
import 'three/examples/jsm/postprocessing/EffectComposer';
import 'three/examples/jsm/postprocessing/RenderPass';
import 'three/examples/jsm/postprocessing/ShaderPass';
import 'three/examples/jsm/shaders/GammaCorrectionShader';
import 'three/examples/jsm/math/SimplexNoise';
import 'three/examples/jsm/controls/DeviceOrientationControls';
import 'three/examples/jsm/controls/FlyControls';
import 'three/examples/jsm/controls/OrbitControls';
import 'three/examples/jsm/controls/TrackballControls';
import 'three/examples/jsm/controls/TransformControls';
import 'lodash.pick';
import 'lodash.omit';
import 'three/examples/jsm/controls/PointerLockControls';
import 'three/examples/jsm/loaders/FBXLoader';
import 'three/examples/jsm/loaders/GLTFLoader';
import 'three/examples/jsm/loaders/DRACOLoader';
import 'three/examples/jsm/libs/meshopt_decoder.module.js';
import 'zustand';
import '@babel/runtime/helpers/esm/defineProperty';
export { B as BlurPass, M as MeshReflectorMaterial } from '../MeshReflectorMaterial-fdc52c9a.js';
import 'three/examples/js/libs/stats.min';
import 'detect-gpu';
import 'three/examples/jsm/modifiers/SimplifyModifier';
import 'three/examples/jsm/modifiers/TessellateModifier';
import 'three/examples/jsm/modifiers/EdgeSplitModifier';
import 'three/examples/jsm/modifiers/CurveModifier';
import 'three/examples/jsm/objects/Sky';
import 'three/examples/jsm/shaders/HorizontalBlurShader';
import 'three/examples/jsm/shaders/VerticalBlurShader';
import '../helpers/matcap-assets.js';
import '../helpers/normal-assets.js';
import { unmountComponentAtNode, render } from 'react-dom';
import { useTransition, a } from '@react-spring/web';

const v1 = new Vector3();
const v2 = new Vector3();
const v3 = new Vector3();

function defaultCalculatePosition(el, camera, size) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
}

function isObjectBehindCamera(el, camera) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}

function objectScale(el, camera) {
  if (camera instanceof OrthographicCamera) {
    return camera.zoom;
  } else if (camera instanceof PerspectiveCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
}

function objectZIndex(el, camera, zIndexRange) {
  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const dist = objectPos.distanceTo(cameraPos);
    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    const B = zIndexRange[1] - A * camera.far;
    return Math.round(A * dist + B);
  }

  return undefined;
}

const epsilon = value => Math.abs(value) < 1e-10 ? 0 : value;

function getCSSMatrix(matrix, multipliers, prepend = '') {
  let matrix3d = 'matrix3d(';

  for (let i = 0; i !== 16; i++) {
    matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? ',' : ')');
  }

  return prepend + matrix3d;
}

const getCameraCSSMatrix = (multipliers => {
  return matrix => getCSSMatrix(matrix, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);

const getObjectCSSMatrix = (scaleMultipliers => {
  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), 'translate(-50%,-50%)');
})(f => [1 / f, 1 / f, 1 / f, 1, -1 / f, -1 / f, -1 / f, -1, 1 / f, 1 / f, 1 / f, 1, 1, 1, 1, 1]);

const Html = /*#__PURE__*/forwardRef((_ref, ref) => {
  var _portal$current;

  let {
    children,
    eps = 0.001,
    style,
    className,
    prepend,
    center,
    fullscreen,
    portal,
    distanceFactor,
    sprite = false,
    transform = false,
    zIndexRange = [16777271, 0],
    calculatePosition = defaultCalculatePosition
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "eps", "style", "className", "prepend", "center", "fullscreen", "portal", "distanceFactor", "sprite", "transform", "zIndexRange", "calculatePosition"]);

  const {
    gl,
    scene,
    camera,
    size
  } = useThree();
  const [el] = useState(() => document.createElement('div'));
  const group = useRef(null);
  const oldZoom = useRef(0);
  const oldPosition = useRef([0, 0]);
  const transformOuterRef = useRef(null);
  const transformInnerRef = useRef(null);
  const target = (_portal$current = portal == null ? void 0 : portal.current) != null ? _portal$current : gl.domElement.parentNode;
  useEffect(() => {
    if (group.current) {
      scene.updateMatrixWorld();

      if (transform) {
        el.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
      } else {
        const vec = calculatePosition(group.current, camera, size);
        el.style.cssText = "position:absolute;top:0;left:0;transform:translate3d(" + vec[0] + "px," + vec[1] + "px,0);transform-origin:0 0;";
      }

      if (target) {
        if (prepend) target.prepend(el);else target.appendChild(el);
      }

      return () => {
        if (target) target.removeChild(el);
        unmountComponentAtNode(el);
      };
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [target, transform]);
  const styles = useMemo(() => {
    if (transform) {
      return {
        position: 'absolute',
        top: 0,
        left: 0,
        width: size.width,
        height: size.height,
        transformStyle: 'preserve-3d',
        pointerEvents: 'none'
      };
    } else {
      return _extends({
        position: 'absolute',
        transform: center ? 'translate3d(-50%,-50%,0)' : 'none'
      }, fullscreen && {
        top: -size.height / 2,
        left: -size.width / 2,
        width: size.width,
        height: size.height
      }, style);
    }
  }, [style, center, fullscreen, size, transform]);
  const transformInnerStyles = useMemo(() => _extends({
    position: 'absolute',
    pointerEvents: 'auto'
  }, style), [style]);
  useLayoutEffect(() => {
    if (transform) {
      render( /*#__PURE__*/createElement("div", {
        ref: transformOuterRef,
        style: styles
      }, /*#__PURE__*/createElement("div", {
        ref: transformInnerRef,
        style: transformInnerStyles
      }, /*#__PURE__*/createElement("div", {
        ref: ref,
        className: className,
        children: children
      }))), el);
    } else {
      render( /*#__PURE__*/createElement("div", {
        ref: ref,
        style: styles,
        className: className,
        children: children
      }), el);
    }
  });
  useFrame(() => {
    if (group.current) {
      camera.updateMatrixWorld();
      const vec = transform ? oldPosition.current : calculatePosition(group.current, camera, size);

      if (transform || Math.abs(oldZoom.current - camera.zoom) > eps || Math.abs(oldPosition.current[0] - vec[0]) > eps || Math.abs(oldPosition.current[1] - vec[1]) > eps) {
        el.style.display = !isObjectBehindCamera(group.current, camera) ? 'block' : 'none';
        el.style.zIndex = "" + objectZIndex(group.current, camera, zIndexRange);

        if (transform) {
          const [widthHalf, heightHalf] = [size.width / 2, size.height / 2];
          const fov = camera.projectionMatrix.elements[5] * heightHalf;
          const {
            isOrthographicCamera,
            top,
            left,
            bottom,
            right
          } = camera;
          const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);
          const cameraTransform = isOrthographicCamera ? "scale(" + fov + ")translate(" + epsilon(-(right + left) / 2) + "px," + epsilon((top + bottom) / 2) + "px)" : "translateZ(" + fov + "px)";
          let matrix = group.current.matrixWorld;

          if (sprite) {
            matrix = camera.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(group.current.scale);
            matrix.elements[3] = matrix.elements[7] = matrix.elements[11] = 0;
            matrix.elements[15] = 1;
          }

          el.style.width = size.width + 'px';
          el.style.height = size.height + 'px';
          el.style.perspective = isOrthographicCamera ? '' : fov + "px";

          if (transformOuterRef.current && transformInnerRef.current) {
            transformOuterRef.current.style.transform = "" + cameraTransform + cameraMatrix + "translate(" + widthHalf + "px," + heightHalf + "px)";
            transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400));
          }
        } else {
          const scale = distanceFactor === undefined ? 1 : objectScale(group.current, camera) * distanceFactor;
          el.style.transform = "translate3d(" + vec[0] + "px," + vec[1] + "px,0) scale(" + scale + ")";
        }

        oldPosition.current = vec;
        oldZoom.current = camera.zoom;
      }
    }
  });
  return /*#__PURE__*/createElement("group", _extends({}, props, {
    ref: group
  }));
});

const styles = {
  container: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    background: '#171717',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 1000
  },
  inner: {
    width: 100,
    height: 3,
    background: '#272727',
    textAlign: 'center'
  },
  bar: {
    height: 3,
    width: '100%',
    background: 'white',
    transformOrigin: 'left center'
  },
  data: {
    display: 'inline-block',
    position: 'relative',
    fontVariantNumeric: 'tabular-nums',
    marginTop: '0.8em',
    color: '#f0f0f0',
    fontSize: '0.6em',
    fontFamily: "-apple-system, BlinkMacSystemFont, \"Inter\", \"Segoe UI\", \"Helvetica Neue\", Helvetica, Arial, Roboto, Ubuntu, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"",
    whiteSpace: 'nowrap'
  }
};
function Loader({
  containerStyles,
  innerStyles,
  barStyles,
  dataStyles,
  dataInterpolation = p => "Loading " + (p * 100).toFixed(2) + "%",
  initialState = active => active
}) {
  const {
    active,
    progress
  } = useProgress();
  const transition = useTransition(initialState(active), {
    from: {
      opacity: 1,
      progress: 0
    },
    leave: {
      opacity: 0
    },
    update: {
      progress: progress / 100
    }
  });
  return transition(({
    progress,
    opacity
  }, active) => active && /*#__PURE__*/createElement(a.div, {
    style: _extends({}, styles.container, {
      opacity
    }, containerStyles)
  }, /*#__PURE__*/createElement("div", null, /*#__PURE__*/createElement("div", {
    style: _extends({}, styles.inner, innerStyles)
  }, /*#__PURE__*/createElement(a.div, {
    style: _extends({}, styles.bar, {
      scaleX: progress
    }, barStyles)
  }), /*#__PURE__*/createElement(a.span, {
    style: _extends({}, styles.data, dataStyles)
  }, progress.to(dataInterpolation))))));
}

export { Html, Loader };
